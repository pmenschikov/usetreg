/*
 * small 1-wire lib for DS18B20 
 */

#define F_CPU	8000000UL
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>


PROGMEM unsigned char leds[16] =
{  // cgbhfdae
	0b10101111, // 0
	0b10100000, // 1
	0b01100111, // 2
	0b11001110, // 3
	0b11101000, // 4
	0b11001110, // 5
	0b11001111, // 6
	0b10100010, // 7
	0b11101111, // 8
	0b11101110, // 9
	0b01000000, // 9
	0b01000000, // 9
	0b01000000, // 9
	0b01000000, // 9
	0b01000000, // 9
	0b01000000 // 9
};

#define N 6

#define V_MUL	2938	//(2.5*11) * 100
#define V_OFF	0
#define C_MUL	9846	//(2.5*11) * 1000
#define C_OFF	0

enum {VOLTAGE_CHANNEL=1, CURRENT_CHANNEL=0};

volatile unsigned char display[N];


// обработчик прерывания таймера0 по переполнению
// организует посегментную динамическую индикацию
ISR(TIMER0_OVF_vect)
{
	static unsigned char pos = 0;
	static unsigned char mask = 1;


	PORTB |= 0xff;
	PORTD = (display[pos] &mask);
	mask <<= 1;
	switch(pos)
	{
		case 3:
			PORTB &= ~_BV(PINB7);
			break;
		case 4:
			PORTB &= ~_BV(PINB6);
			break;
		case 5:
			PORTB &= ~_BV(PINB3);
			break;
		default:
			PORTB &= ~(0x01 << pos);
	}
	if(!mask)
	{
		if(++pos == N)
			pos = 0;
		mask = 1;
	}
}

static void init()
{


	//индикация
	DDRD = 0xFF; // сегменты
	DDRB = 0x3F; // общие катоды

	//таймер для индикации
	TCCR0 = _BV(CS01);	// делитель на 8 
	TIMSK = _BV(TOIE0); // прерывание по переполнению

	//ADC - делитель для АЦП - 128
	ADCSRA |= _BV(ADEN)| _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);

}

// функция для получения результата с АЦП
// ch - номер канала
static uint16_t get_adc(uint8_t ch)
{
	ADMUX = _BV(REFS0)|_BV(REFS0)|(ch);
	ADCSRA |= _BV(ADSC);
	while(!(ADCSRA&_BV(ADIF)));
	sleep_mode();
	return ADC;
}

// вывод на индикаторы
// val - значение
// ch - номер канала
static void output(uint16_t val, uint8_t ch)
{
	display[0+ch*3]=pgm_read_byte(&leds[val%10]);
	val/=10;
	display[1+ch*3]=pgm_read_byte(&leds[val%10]);
	val/=10;
	display[2+ch*3]=pgm_read_byte(&leds[val%10]);
	
	display[1+VOLTAGE_CHANNEL*3] |= _BV(4);
	display[2+CURRENT_CHANNEL*3] |= _BV(4);
}

int __attribute((OS_main)) main()
{
	uint32_t voltage = 0;
	uint32_t current = 0;
	init();	
	sei();
	for(;;)
	{
		voltage = (uint32_t)(get_adc(VOLTAGE_CHANNEL))*10UL;
		voltage = voltage * V_MUL + V_OFF;
		voltage /= 102400;

		current = (uint32_t)(get_adc(CURRENT_CHANNEL))*10UL;
		current = current * C_MUL + C_OFF;
		current /= 102400;

		output((uint16_t)voltage, VOLTAGE_CHANNEL);
		output((uint16_t)current, CURRENT_CHANNEL);

		_delay_ms(200);
	}
	return 0;
}

